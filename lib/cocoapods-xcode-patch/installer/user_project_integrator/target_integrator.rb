module Pod
  class Installer
    class UserProjectIntegrator
      # This class is responsible for integrating the library generated by a
      # {TargetDefinition} with its destination project.
      #
      class TargetIntegrator
        class << self
          alias_method :hook_create_or_update_copy_resources_script_phase_to_target, :create_or_update_copy_resources_script_phase_to_target

          alias_method :hook_create_or_update_embed_frameworks_script_phase_to_target, :create_or_update_embed_frameworks_script_phase_to_target

          def create_or_update_copy_resources_script_phase_to_target(native_target, script_path, input_paths_by_config = {}, output_paths_by_config = {})
            # CocoaPods 1.7.5 contains bug, when there is one pod using `s.resource = 'ABC.xcassets'`
            # Then the Xcode Input File List should add the `Assets.car` as input file
            # Or Xcode 11 will report error
            # Note the Legacy Build System does not have this issue
            if patch_legacy_build_system?
              return hook_create_or_update_copy_resources_script_phase_to_target(native_target, script_path, input_paths_by_config, output_paths_by_config)
            end

            assets_car_path = "${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/Assets.car"
            input_paths_by_config.each do |key, paths|
              if paths.any? { |path| path == assets_car_path }
                next
              end
              if paths.any? { |path| path.end_with? "xcassets" }
                paths << assets_car_path
              end
            end
            
            phase = TargetIntegrator.create_or_update_shell_script_build_phase(native_target, BUILD_PHASE_PREFIX + COPY_PODS_RESOURCES_PHASE_NAME)
            if Config.instance.sandbox.development_pods.empty?
              phase.shell_script = %("#{script_path}"\n)
            else
              phase.shell_script = %("#{script_path}"\nfind \"${PODS_ROOT}\" -type f -name *resources.sh -exec bash -c \"touch \\\"{}\\\"\" \\;\n)
            end
            TargetIntegrator.set_input_output_paths(phase, input_paths_by_config, output_paths_by_config)
          end

          def create_or_update_embed_frameworks_script_phase_to_target(native_target, script_path, input_paths_by_config = {}, output_paths_by_config = {})
            phase = TargetIntegrator.create_or_update_shell_script_build_phase(native_target, BUILD_PHASE_PREFIX + EMBED_FRAMEWORK_PHASE_NAME)
            if Config.instance.sandbox.development_pods.empty?
              phase.shell_script = %("#{script_path}"\n)
            else
              phase.shell_script = %("#{script_path}"\nfind \"${PODS_ROOT}\" -type f -name *frameworks.sh -exec bash -c \"touch \\\"{}\\\"\" \\;\n)
            end
            TargetIntegrator.set_input_output_paths(phase, input_paths_by_config, output_paths_by_config)
          end

          def patch_workspace_path
            # Current Workspace's path
            podfile_path = Config.instance.podfile_path
            return nil if !podfile_path

            podfile_path.parent.each_child do |f|
              return f if f.extname == '.xcworkspace'
            end
            return nil
          end


          def patch_legacy_build_system?
            # Check whether current workspace use Legacy Build System
            workspace_path = patch_workspace_path
            return false if !workspace_path
            
            xcsettings_path = File.join(workspace_path, 'xcshareddata', 'WorkspaceSettings.xcsettings')
            return false if !File.exist?(xcsettings_path)
            xcsettings = Xcodeproj::Plist.read_from_path(xcsettings_path)
            return false if !xcsettings

            return xcsettings['BuildSystemType'] == 'Original'
          end
        end
      end
    end
  end
end